# auto-generated by x2py xpiler

from .event import *
from .util.misc import *

class BuiltinEventType:
    HEARTBEAT_EVENT = -1
    FLOW_START = -2
    FLOW_STOP = -3
    TIMEOUT_EVENT = -4

class MyCell(Cell):
    tag = Cell.Tag(None, [('Foo', 9)])

    def __init__(self, length=0):
        super().__init__(len(MyCell.tag.props) + length)
        base = MyCell.tag.offset
        self.values[base + 0] = ""

    @property
    def foo(self):
        return self.values[MyCell.tag.offset + 0]
    @foo.setter
    def foo(self, value):
        index = MyCell.tag.offset + 0
        self.fingerprint.touch(index)
        self.values[index] = value

    def type_id(self):
        return MyCell.tag.type_id

    def type_tag(self):
        return MyCell.tag

    def equals(self, other):
        if not super().equals(other):
            return False
        base = MyCell.tag.offset
        if self.values[base + 0] != other.values[base + 0]:
            return False
        return True

    def equivalent(self, other):
        if not super().equivalent(other):
            return False
        base = MyCell.tag.offset
        if other.fingerprint.get(base + 0):
            if self.values[base + 0] != other.values[base + 0]:
                return False
        return True

    def hash_code(self, fingerprint):
        value = super().hash_code(fingerprint)
        base = MyCell.tag.offset
        if fingerprint.get(base + 0):
            value = hash_update(value, base + 0)
            value = hash_update(value, hash(self.values[base + 0]))
        return value

class HeartbeatEvent(Event):
    tag = Event.Tag(Event.tag, [],
        BuiltinEventType.HEARTBEAT_EVENT)

    def __init__(self, length=0):
        super().__init__(len(HeartbeatEvent.tag.props) + length)
        base = HeartbeatEvent.tag.offset
        pass

    def type_id(self):
        return HeartbeatEvent.tag.type_id

    def type_tag(self):
        return HeartbeatEvent.tag

    def equals(self, other):
        if not super().equals(other):
            return False
        base = HeartbeatEvent.tag.offset
        return True

    def equivalent(self, other):
        if not super().equivalent(other):
            return False
        base = HeartbeatEvent.tag.offset
        return True

    def hash_code(self, fingerprint):
        value = super().hash_code(fingerprint)
        base = HeartbeatEvent.tag.offset
        return value

class FlowStart(Event):
    tag = Event.Tag(Event.tag, [],
        BuiltinEventType.FLOW_START)

    def __init__(self, length=0):
        super().__init__(len(FlowStart.tag.props) + length)
        base = FlowStart.tag.offset
        pass

    def type_id(self):
        return FlowStart.tag.type_id

    def type_tag(self):
        return FlowStart.tag

    def equals(self, other):
        if not super().equals(other):
            return False
        base = FlowStart.tag.offset
        return True

    def equivalent(self, other):
        if not super().equivalent(other):
            return False
        base = FlowStart.tag.offset
        return True

    def hash_code(self, fingerprint):
        value = super().hash_code(fingerprint)
        base = FlowStart.tag.offset
        return value

class FlowStop(Event):
    tag = Event.Tag(Event.tag, [],
        BuiltinEventType.FLOW_STOP)

    def __init__(self, length=0):
        super().__init__(len(FlowStop.tag.props) + length)
        base = FlowStop.tag.offset
        pass

    def type_id(self):
        return FlowStop.tag.type_id

    def type_tag(self):
        return FlowStop.tag

    def equals(self, other):
        if not super().equals(other):
            return False
        base = FlowStop.tag.offset
        return True

    def equivalent(self, other):
        if not super().equivalent(other):
            return False
        base = FlowStop.tag.offset
        return True

    def hash_code(self, fingerprint):
        value = super().hash_code(fingerprint)
        base = FlowStop.tag.offset
        return value

class TimeoutEvent(Event):
    tag = Event.Tag(Event.tag, [('Key', 15), ('IntParam', 5), ('Test', 13)],
        BuiltinEventType.TIMEOUT_EVENT)

    def __init__(self, length=0):
        super().__init__(len(TimeoutEvent.tag.props) + length)
        base = TimeoutEvent.tag.offset
        self.values[base + 0] = None
        self.values[base + 1] = 0
        self.values[base + 2] = None

    @property
    def key(self):
        return self.values[TimeoutEvent.tag.offset + 0]
    @key.setter
    def key(self, value):
        index = TimeoutEvent.tag.offset + 0
        self.fingerprint.touch(index)
        self.values[index] = value

    @property
    def int_param(self):
        return self.values[TimeoutEvent.tag.offset + 1]
    @int_param.setter
    def int_param(self, value):
        index = TimeoutEvent.tag.offset + 1
        self.fingerprint.touch(index)
        self.values[index] = value

    @property
    def test(self):
        return self.values[TimeoutEvent.tag.offset + 2]
    @test.setter
    def test(self, value):
        index = TimeoutEvent.tag.offset + 2
        self.fingerprint.touch(index)
        self.values[index] = value

    def type_id(self):
        return TimeoutEvent.tag.type_id

    def type_tag(self):
        return TimeoutEvent.tag

    def equals(self, other):
        if not super().equals(other):
            return False
        base = TimeoutEvent.tag.offset
        if self.values[base + 0] != other.values[base + 0]:
            return False
        if self.values[base + 1] != other.values[base + 1]:
            return False
        if self.values[base + 2] != other.values[base + 2]:
            return False
        return True

    def equivalent(self, other):
        if not super().equivalent(other):
            return False
        base = TimeoutEvent.tag.offset
        if other.fingerprint.get(base + 0):
            if self.values[base + 0] != other.values[base + 0]:
                return False
        if other.fingerprint.get(base + 1):
            if self.values[base + 1] != other.values[base + 1]:
                return False
        if other.fingerprint.get(base + 2):
            if self.values[base + 2] != other.values[base + 2]:
                return False
        return True

    def hash_code(self, fingerprint):
        value = super().hash_code(fingerprint)
        base = TimeoutEvent.tag.offset
        if fingerprint.get(base + 0):
            value = hash_update(value, base + 0)
            value = hash_update(value, hash(self.values[base + 0]))
        if fingerprint.get(base + 1):
            value = hash_update(value, base + 1)
            value = hash_update(value, hash(self.values[base + 1]))
        if fingerprint.get(base + 2):
            value = hash_update(value, base + 2)
            value = hash_update(value, hash(self.values[base + 2]))
        return value
